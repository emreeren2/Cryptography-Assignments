# -*- coding: utf-8 -*-
"""cs411_hw1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y3U6QPpljuEHKmMATuLIJVCIn_dPLvNK

# Problem 1
"""

print('--------- problem 1 start ---------')

cipher = "NKWZ"
plaintext = ""

for key in range(0, 26): # iterating over each possible keys
  for letter in cipher:
    int_char = ord(letter) - key  # obtaining integer equalivent of the decrypted characther
    if(int_char < 65):          # Since i work with ASCII in this question if integer equalivent of the decrypted char is smaller than 'A' = 65 i apply + 26, it is basically modulo operation
      int_char = int_char + 26  # as i described above comment, it is basically modulo operation

    encrypted_char = chr(int_char) # converting the founded integer (founded with key) to char
    plaintext = plaintext + encrypted_char # we add characther to plaintext

  print("key: ", key, chr(key+65), "  plaintext: ", plaintext) # after whole cipher-text decrypted for the current key, we print the corresponding plaintext
  plaintext = ""                                               # then we reset the plaintext for the next key.

print("key 22 'W': ROAD")
print("key 10 'K': DAMP")

print('--------- problem 1 finish ---------')

"""# Problem 2

"""

print('--------- problem 2 start ---------')

cipher = "REZANSZ JRE VRDB CLXGNOZ. NEMZ R TOBRG VRE JRE HOLGB LG."
plaintext = ""
letter_count = {'A':0, 'B':0, 'C':0, 'D':0, 'E':0, 'F':0, 'G':0, 'H':0, 'I':0,
                'J':0, 'K':0, 'L':0, 'M':0, 'N':0, 'O':0, 'P':0, 'Q':0,
                'R':0, 'S':0,  'T':0, 'U':0, 'V':0, 'W':0, 'X':0, 'Y':0, 'Z':0, ' ': -999, '.': -999}

letters = {'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7, 'I':8,
           'J':9, 'K':10, 'L':11, 'M':12, 'N':13, 'O':14, 'P':15, 'Q':16,
           'R':17, 'S':18,  'T':19, 'U':20, 'V':21, 'W':22, 'X':23, 'Y':24,
           'Z':25}

inv_letters = {0:'A', 1:'B', 2:'C', 3:'D', 4:'E', 5:'F', 6:'G', 7:'H',
               8:'I', 9:'J', 10:'K', 11:'L', 12:'M', 13:'N', 14:'O', 15:'P',
              16:'Q', 17:'R', 18:'S', 19:'T', 20:'U', 21:'V', 22:'W', 23:'X',
              24:'Y', 25:'Z'}

# calculating the number of repetations for each characthers
for letter in cipher:
  letter_count[letter] += 1

max_occurance = max(letter_count, key=letter_count.get) # getting the most repeated key in the dictionary
print("The most frequent letter in cipher:", max_occurance)

beta = letters['R'] - letters['A']
print(beta)

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
      raise Exception('modular inverse does not exist')
    else:
      print("alpha:", a, " - gamma:", x%m)
      return x % m

# gcd(alpha, 26) should be 1, so the possible alphas are;
alpha_keys = [1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25]
gamma = 0

gamma_keys = []

# we calculate modulo inverse of alphas which are gamma keys. We print alpha key corresponding gamma key
for alpha in alpha_keys:
  gamma_keys.append(modinv(alpha, 26))

gamma_keys

for g in gamma_keys: 
  for char in cipher:
    if(char == ' '):  # we assume space char did not be encyrpted so we pass it
      plaintext += ' '
    elif(char == '.'): # we assume '.' char did not be encyrpted so we pass it
      plaintext += '.'
    else:
      tetha = 26-(g*beta)%26  # we calculating theta with the current gamma and founded beta
      plaintext_char = (letters[char]*g + tetha) % 26 # we apply keys
      plaintext += inv_letters[plaintext_char] # we convert decyrpted char (which is integer), to characther
  
  # we print key pairs and decyrpted text then we reset the plaintext for the next key pair try.
  print("gamma:",g, "  -  " "tetha:", tetha)
  print(plaintext, "\n")
  plaintext = ""

gamma = 3
alpha = 9 # we printed alpha gamma pairs in inverse modulo function, so if we check the output, we see that when gamma is 3, alpha is 9
tetha = 1
print("decryption key pair is: ", "(", gamma, ",", tetha, ")", "--> (gamma,tetha)")
print("encryption key pari is: ", "(", alpha, ",", beta, ")", "--> (alpha,beta)")

print('--------- problem 2 finish ---------')

"""# Problem 3"""

print('--------- problem 3 start ---------')

import requests # if this lib isn't installed yet --> pip install requests or pip3 intall requests


### DO NOT CHANGE HERE ######

API_URL = 'http://cryptlygos.pythonanywhere.com' # DO NOT change url 

def getCipher(my_id):
    endpoint = '{}/{}/{}'.format(API_URL, "affine_game", my_id )
    response = requests.get(endpoint) 	#get your ciphertext and most freq. letter
    ctext, letter = "", ""
    if response.ok:	#if you get your ciphertext succesfully
        c = response.json()
        ctext = c[0]    #this is your ciphertext
        letter = c[1] 	#the most frequent letter in your plaintext
    elif(response.status_code == 404):
        print("We dont have a student with this ID. Check your id num")
    else:
        print("It was supposed to work:( Contact your TA")
    
    return ctext, letter
    
    
def sendMessage(my_id, plaintext):    
    endpoint = '{}/{}/{}/{}'.format(API_URL, "affine_game", my_id, plaintext)
    response = requests.put(endpoint)
    if response.ok:
        c = response.json()
        print(c)
    elif(response.status_code == 404):
        print("Nope, Try again")
    elif(response.status_code == 401):
        print("Check your ID number")
    else:
        print("How did you get in here? Contact your TA")

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
      print('modular inverse does not exist for alpha =', a)
    else:
      print("alpha:", a, " - gamma:", x%m)
      return x % m


if __name__ == '__main__':
    my_id = 25139	# change this to your id number. it should be 5 digit number
    
    cipher_text, most_frequent_letter = getCipher(my_id)
    print("Cipher text is: ", cipher_text)
    """
    Use the ciphertext and the most frequent letter of the ciphertext
    Find the plaintext.
    And assing it to below variable named plainText 
    If your answer is correct it prints out "Congrats"
    
    """
    plainText = ""

    letters = {'A':0, 'B':1, 'C':2, 'Ç':3, 'D':4, 'E':5, 'F':6, 'G':7, 'Ğ':8, 'H':9, 'I':10, 
               'İ': 11, 'J':12, 'K':13, 'L':14, 'M':15, 'N':16, 'O':17, 'Ö':18, 'P':19, 
               'R':20, 'S':21, 'Ş':22, 'T':23, 'U':24, 'Ü':25, 'V':26, 'Y':27, 'Z':28, '.':29, ',':30}

    inv_letters = {0:'A', 1:'B', 2:'C', 3:'Ç', 4:'D', 5:'E', 6:'F', 7:'G', 8:'Ğ', 9:'H', 10:'I', 
                   11:'İ', 12:'J', 13:'K', 14:'L', 15:'M', 16:'N', 17:'O', 18:'Ö', 19:'P', 
                   20:'R', 21:'S', 22:'Ş', 23:'T', 24:'U', 25:'Ü', 26:'V', 27:'Y', 28:'Z', 29:'.', 30:','}

    letter_count = {'A':0, 'B':0, 'C':0, 'Ç':0, 'D':0, 'E':0, 'F':0, 'G':0, 'Ğ':0, 'H':0, 'I':0, 
                    'İ': 0, 'J':0, 'K':0, 'L':0, 'M':0, 'N':0, 'O':0, 'Ö':0, 'P':0, 
                    'R':0, 'S':0, 'Ş':0, 'T':0, 'U':0, 'Ü':0, 'V':0, 'Y':0, 'Z':0, '.':0, ',':0, ' ': -9999, "'":-9999}

    # gcd(a, 31) should be 1 so, possible alpha keys are;
    alpha_keys = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]
    gamma_keys = []

    gamma = 0
    tetha = 0
    alpha = 0
    beta = 0

    print("")
    print("---------")
    print("The most frequent letter in plain text is '" + most_frequent_letter + "'")

    # calculating the number of repetations for each characthers and printing the most repeated char
    for letter in cipher_text:
        letter_count[letter] += 1
    max_occurance_cipher = max(letter_count, key=letter_count.get)
    print("The most frequent letter in cipher text is '"+ max_occurance_cipher + "'")

    print("---------")
    print("")

    # we know the most repeated char both in plaintext and ciphertext, so we can obtain beta
    beta =  letters[max_occurance_cipher] - letters[most_frequent_letter]
    print("beta is", beta, "('N' - 'A')")
    print("")

    # we calculate possible gamma keys with possible alpha keys with the help of modinv function
    for alpha in alpha_keys:
      gamma_keys.append(modinv(alpha, 31))
    print("")


    for g in gamma_keys: # we try all gamma keys
      for char in cipher_text: # for each char in the cipher text
        if(char == ' '): # we assume space char did not be encyrpted so we pass it
          plainText += ' '
        elif(char == "'"): # we assume ''' char did not be encyrpted so we pass it
          plainText += "'"
        else:
          tetha = 31-(g*beta)%31 # we calculating theta with the current gamma and founded beta
          plaintext_char = (letters[char]*g + tetha) % 31 # we apply keys
          plainText += inv_letters[plaintext_char] # we convert decyrpted char (which is integer), to characther
      print("gamma:",g, "  -  " "tetha:", tetha)
      print(plainText, "\n")
      plainText = ""

    # we put back space and "'" chars to the plain text
    for char in cipher_text:
      if(char == ' '): 
        plainText += ' '
      elif(char == "'"):
        plainText += "'"
      else:
        plaintext_char = (letters[char]*4 + 29) % 31
        plainText += inv_letters[plaintext_char]

    print("")
    print("---------")
    print("Plain text can be:", plainText)
    print("---------")
    print("")
    sendMessage(my_id, plainText)

gamma = 4
tetha = 29
alpha = 8 # we printed alpha gamma pairs in inverse modulo function, so if we check the output, we see that when gamma is 4, alpha is 8
print("decryption key pair is: ", "(", gamma, ",", tetha, ")", "--> (gamma,tetha)")
print("encryption key pari is: ", "(", alpha, ",", beta, ")", "--> (alpha,beta)")

print('--------- problem 3 finish ---------')

"""# Problem 8 (Bonus)"""

print('--------- problem 8 start ---------')

letters ={'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7, 'I':8,
         'J':9, 'K':10, 'L':11, 'M':12, 'N':13, 'O':14, 'P':15, 'Q':16,
         'R':17, 'S':18,  'T':19, 'U':20, 'V':21, 'W':22, 'X':23, 'Y':24,
         'Z':25}

inv_letters = {0:'A', 1:'B', 2:'C', 3:'D', 4:'E', 5:'F', 6:'G', 7:'H',
                 8:'I', 9:'J', 10:'K', 11:'L', 12:'M', 13:'N', 14:'O', 15:'P',
                 16:'Q', 17:'R', 18:'S', 19:'T', 20:'U', 21:'V', 22:'W', 23:'X',
                 24:'Y', 25:'Z'}

letter_count = {'A':0, 'B':0, 'C':0, 'D':0, 'E':0, 'F':0, 'G':0, 'H':0, 'I':0,
                'J':0, 'K':0, 'L':0, 'M':0, 'N':0, 'O':0, 'P':0, 'Q':0,
                'R':0, 'S':0, 'T':0, 'U':0, 'V':0, 'W':0, 'X':0, 'Y':0,
                'Z':0}


cipher_text = "Iur tvlrc ig vnc wof il tvps aoiutpy wu wfiqo ajl aln yrs jrcahld cqihl-rhsye gs cue fuahn gngairuhpol tvht kayls y pobpcr hoe cqihl mf o Yoaksmejlsy, tfe gaunir tal tvl eouos od ab Lilshlil, abk tfe wnnmrout kab ahc eebaj ot hnw ccslcgs wrcswkelt. Hoar ibztgtiaimn, ulnrlstel, ig h cmufa. Ir cou bc tvl Sspflmc Ccbrr ot ahc Ubptcd Saareg vr rhs oukbzlsr J.D josrh pn rhs sald, cy tfig oolofhbje qvupt koiah mvu qefce. Muf josrhz hyvs ahcif maslhz, aq dcls ynm oukab pnqtwauricu, bst wu tfig josnhyy muf josrhz ape hoe ersht jejllcrg, hnb ib vup ccbrrs osl keb hrc cflarer lqsaz. P'm lo wkeylwzt ro pllgejl fgrasy gn hoe gnhlgpihf od oiy cmufas ynr pn rhs qupy-gfsrea ahyt wz nm irlaj tc te, gt wz a jijpne, wcykgnu yeylway. Eebalcmsu, a aoiyt gs bv bcthlr rhou eycv tal ot fos swatgnu iedofl mc ob ahgs xbrw. A qvupt wz ollm hs qoiud ys was huff, ald o qupy wz ollm hs qoiud ys hoe keb dhm more gt iw. I ym qvndirlnr tvht woi neltzlmcn kplj rscicw kptfoia pysgpol tvl etirlnae mvu fajl hcafk, cmms ao y dsjiqicu, ald flsrofl tfig kedebkalt hv hgs thmglm. Pn rhs uake cm Gmd, rv ymuf kury."
cipher_text_original = cipher_text # at the end we use this to put back punctuation symbols, spaces and adjusting letter size (upper/back) 
                                    # because to be able to work easy we remove all of them in cipher and make all char upper


# punctuation symbols and spaces are removed
symbols = '''!()-[]{};:'"\,<>./?@#$%^&*_~ '''
for char in cipher_text:
    if char in symbols:
        cipher_text = cipher_text.replace(char, "")

# all chars are uppered
cipher_text = cipher_text.upper()

# we add space at the beggining of the cipher text
def shiftCipher(text):
  return text[:0] + ' ' + text[0:]

# this function takes shifted cipher as arguement
# we have original cipher text as cipher_text
# letters that are in the same indexes are compared 
# if they are same, we increase coincidence variable by one
# at the end of the funtion we append the calculated number in the num_of_coincidence
# array which is described below cell.
def countLetters(shifted_cipher):
  counter = 0
  coincidence = 0
  for char in cipher_text:
    if(char == shifted_cipher[counter]):
      coincidence += 1
    counter += 1
  num_of_coincidences.append(coincidence)

max_length_tried = 20
shifted_cipher = cipher_text
num_of_coincidences = [] # stores inv_letters dictionaries for each key length. index 0 => key length 0, index 1 => key length 1, index 2 => key length 2 

# for each shift amount we calculate coincidences
for i in range(max_length_tried):
  countLetters(shifted_cipher)
  shifted_cipher = shiftCipher(shifted_cipher)

for i in range(len(num_of_coincidences)):
  print("for shift amount", i, "calculated coincidences are", num_of_coincidences[i])

key_length = 5
print("key length can be", key_length)

key = []
for i in range(key_length):
  key.append(0)

clusters = []

def combineRelevantLetters(cluster_no):
  sub_cluster = []
  i = cluster_no
  while i < len(cipher_text):
    sub_cluster.append(i)
    i += key_length
  clusters.append(sub_cluster)

for no in range(key_length):
  combineRelevantLetters(no)

# this cluster shows that which indexes of sub-cipher should be considered.
# As we see in lectures, if key length is 5 we combine 0th 5th 10th 15th.. chars togather
for i in clusters:
  print(i)

letter_count = {'A':0, 'B':0, 'C':0, 'D':0, 'E':0, 'F':0, 'G':0, 'H':0, 'I':0,
                'J':0, 'K':0, 'L':0, 'M':0, 'N':0, 'O':0, 'P':0, 'Q':0,
                'R':0, 'S':0, 'T':0, 'U':0, 'V':0, 'W':0, 'X':0, 'Y':0,
                'Z':0}

letter_counts_array = []

for c_num in range(key_length):
  # reseting letter_count dictionary
  letter_count = {'A':0, 'B':0, 'C':0, 'D':0, 'E':0, 'F':0, 'G':0, 'H':0, 'I':0,
                'J':0, 'K':0, 'L':0, 'M':0, 'N':0, 'O':0, 'P':0, 'Q':0,
                'R':0, 'S':0, 'T':0, 'U':0, 'V':0, 'W':0, 'X':0, 'Y':0,
                'Z':0}
  for j in range(len(clusters[c_num])):
    letter_count[cipher_text[clusters[c_num][j]]] += 1
  letter_counts_array.append(letter_count)

for i in range(len(letter_counts_array)):
  print("for cluster", i, ":",letter_counts_array[i])

sorted_letter_counts = []
for i in range(len(letter_counts_array)):
  sorted_letter_counts.append(list(reversed(sorted(letter_counts_array[i].items(), key=lambda kv: kv[1]))))
  #sorted_letter_counts.append(sorted(letter_counts_array[i].items(), key=lambda kv: kv[1]))

for i in range(len(sorted_letter_counts)):
  print("for cluster", i, ":",sorted_letter_counts[i])

k1 = (letters['L'] - letters['E']) % 26
k2 = (letters['E'] - letters['E']) % 26

k3 = (letters['R'] - letters['E']) % 26
k3_1 = (letters['C'] - letters['E']) % 26

k4_x = (letters['T'] - letters['E']) % 26 # this did not work then i tried second most common letter in alphabet
k4 = (letters['T'] - letters['T']) % 26

k5 = (letters['S'] - letters['E']) % 26
k5_1 = (letters['H'] - letters['E']) % 26


key1 =  [k1,k2,k3,k4,k5]
key2 = [k1,k2,k3_1,k4,k5]
key3 = [k1,k2,k3,k4,k5_1]
key4 =  [k1,k2,k3_1,k4,k5_1]

print(key1)
print(key2)
print(key3)
print(key4)

key1_string = ""
key2_string = "" 
key3_string = ""
key4_string = ""

for i in range(key_length):
  key1_string += inv_letters[key1[i]]
  key2_string += inv_letters[key2[i]]
  key3_string += inv_letters[key3[i]]
  key4_string += inv_letters[key4[i]]
  
  
print("key option 1:", key1_string)
print("key option 2:", key2_string)
print("key option 3:", key3_string)
print("key option 4:", key4_string)

plaintext = ""
i = 0
for char in cipher_text:
  plaintext += inv_letters[(letters[char] - key2[i%key_length]) % 26]
  i += 1

def insertChar(text, char, index):
    return text[:index] + char + text[index:]

# putting back to removed symbols with the help of opriginal cipher
for i in range(len(cipher_text_original)):
  if(cipher_text_original[i] == ' '):
    plaintext = insertChar(plaintext, ' ', i)
  elif(cipher_text_original[i] == '.'):
    plaintext = insertChar(plaintext, '.', i)
  elif(cipher_text_original[i] == '-'):
    plaintext = insertChar(plaintext, '-', i)
  elif(cipher_text_original[i] == ','):
    plaintext = insertChar(plaintext, ',', i)
  elif(cipher_text_original[i] == '\''):
    plaintext = insertChar(plaintext, '\'', i)

# adjusting letter whether lower or upper according to the original cipher
for i in range(len(cipher_text_original)):
  if(cipher_text_original[i].islower()):
    to_be_replaced = plaintext[i].lower()
    plaintext = plaintext[:i] + to_be_replaced + plaintext[i+1:]

plaintext

print("the key was", key2_string)

print('--------- problem 8 finish ---------')

